landmark_coordinates = []  # Initialize an empty list for storing landmarks

    if hand_landmarks:
        for handLMs in hand_landmarks:
            hand_coords = []  # List to store coordinates of a single hand

            for lm in handLMs.landmark:
                x, y = int(lm.x * w), int(lm.y * h)
                hand_coords.append((x, y))  # Add landmark coordinates to the list

                # ... [existing bounding box and drawing code]

            landmark_coordinates.append(hand_coords)  # Add this hand's landmarks to the main list

    # ... [rest of the existing code]

    print(landmark_coordinates)  # Print the list of all landmarks

    # Optionally, you can return the list
    # return landmark_coordinates


def render(triggerModel):
    _, frame = cap.read()

    # ... [previous processing code]

    landmark_coordinates = []  # Initialize an empty list for storing landmarks

    # Define your reference coordinate (example: (x_ref, y_ref) = (100, 50))
    x_ref, y_ref = 100, 50

    if hand_landmarks:
        for handLMs in hand_landmarks:
            hand_coords = []  # List to store coordinates of a single hand

            for lm in handLMs.landmark:
                x, y = int(lm.x * w), int(lm.y * h)
                # Subtract (x_ref, y_ref) from (x, y)
                adjusted_x, adjusted_y = x - x_ref, y - y_ref
                hand_coords.append((adjusted_x, adjusted_y))  # Add adjusted landmark coordinates to the list

                # ... [existing bounding box and drawing code]

            landmark_coordinates.append(hand_coords)  # Add this hand's landmarks to the main list

    # ... [rest of the existing code]

    print(landmark_coordinates)  # Print the list of adjusted landmarks

    # Optionally, you can return the list
    # return landmark_coordinates

# ... [rest of the script]






def render(triggerModel):
    _, frame = cap.read()
    framergb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    result = hands.process(framergb)
    hand_landmarks = result.multi_hand_landmarks

    # Specific coordinates to subtract
    x_sub, y_sub = 50, 50

    # Define the divisor
    divisor = 10

    if hand_landmarks:
        for handLMs in hand_landmarks:
            for lm in handLMs.landmark:
                # Process each landmark
                x, y = lm.x * w, lm.y * h
                x = (x - x_sub) / divisor
                y = (y - y_sub) / divisor

                # Ensure x and y are within frame bounds
                x = max(0, min(int(x), w - 1))
                y = max(0, min(int(y), h - 1))

                # Use the processed coordinates for further application logic if needed

            # Draw landmarks on the original frame




    if hand_landmarks:
        for handLMs in hand_landmarks:
            for lm in handLMs.landmark:
                # Process each landmark
                x, y = lm.x * w, lm.y * h
                x = (x - x_sub) / divisor
                y = (y - y_sub) / divisor

                # Ensure x and y are within frame bounds
                x = max(0, min(int(x), w - 1))
                y = max(0, min(int(y), h - 1))

                # Use the processed coordinates for further application logic if needed

            # Draw landmarks on the original frame






def render(triggerModel):
    _, frame = cap.read()

    framergb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    result = hands.process(framergb)
    hand_landmarks = result.multi_hand_landmarks

    if hand_landmarks:
        for handLMs in hand_landmarks:
            x_max, y_max = 0, 0
            x_min, y_min = w, h

            # Find bounding box dimensions
            for lm in handLMs.landmark:
                x, y = int(lm.x * w), int(lm.y * h)
                x_max, x_min = max(x, x_max), min(x, x_min)
                y_max, y_min = max(y, y_max), min(y, y_min)

            # Resize the box and move to bottom-left
            box_width, box_height = x_max - x_min, y_max - y_min
            scale_factor = box_height / h if box_height > box_width else box_width / w

            new_width, new_height = int(box_width / scale_factor), int(box_height / scale_factor)
            x_min_new, y_min_new = 0, h - new_height
            x_max_new, y_max_new = new_width, h

            # Draw resized box in new position
            cv2.rectangle(frame, (x_min_new, y_min_new), (x_max_new, y_max_new), (0, 255, 0), 2)

            mp_drawing.draw_landmarks(frame, handLMs, mphands.HAND_CONNECTIONS)

    # Rest of your code...







def adjust_box(x_min, y_min, x_max, y_max, frame_width, frame_height):
    box_width, box_height = x_max - x_min, y_max - y_min
    scale_factor = box_height / frame_height if box_height > box_width else box_width / frame_width

    new_width, new_height = int(box_width / scale_factor), int(box_height / scale_factor)
    x_min_new, y_min_new = 0, frame_height - new_height
    x_max_new, y_max_new = new_width, frame_height

    return x_min_new, y_min_new, x_max_new, y_max_new

def render(triggerModel):
    _, frame = cap.read()
    framergb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    result = hands.process(framergb)
    hand_landmarks = result.multi_hand_landmarks

    if hand_landmarks:
        for handLMs in hand_landmarks:
            x_max, y_max = 0, 0
            x_min, y_min = w, h

            for lm in handLMs.landmark:
                x, y = int(lm.x * w), int(lm.y * h)
                x_max, x_min = max(x, x_max), min(x, x_min)
                y_max, y_min = max(y, y_max), min(y, y_min)

            # Call the new function to adjust the box
            x_min_new, y_min_new, x_max_new, y_max_new = adjust_box(x_min, y_min, x_max, y_max, w, h)
            cv2.rectangle(frame, (x_min_new, y_min_new), (x_max_new, y_max_new), (0, 255, 0), 2)

            mp_drawing.draw_landmarks(frame, handLMs, mphands.HAND_CONNECTIONS)

    # Rest of your code...
